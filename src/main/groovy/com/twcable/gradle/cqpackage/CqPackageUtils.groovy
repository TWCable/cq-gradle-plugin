/*
 * Copyright 2015 Time Warner Cable, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.twcable.gradle.cqpackage

import groovy.transform.CompileStatic
import groovy.util.logging.Slf4j
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.DependencySet
import org.gradle.api.artifacts.ProjectDependency
import org.gradle.api.internal.artifacts.CachingDependencyResolveContext
import org.gradle.api.internal.artifacts.ResolvableDependency

import javax.annotation.Nonnull
import java.util.regex.Pattern

import static java.util.Collections.EMPTY_LIST
import static java.util.Collections.EMPTY_SET

@Slf4j
@CompileStatic
final class CqPackageUtils {
    private static final Pattern JAR_NAME_PATTERN = Pattern.compile(/(?i).*\.jar$/)

    /**
     * Returns all JAR files generated by the given project and its project dependencies in
     * the configuration that use the "osgi" plugin.
     */
    @Nonnull
    static Collection<File> allProjectBundleJarFiles(@Nonnull Project project, @Nonnull Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")

        Collection<ProjectDependency> allOsgiProjects = projectDependenciesForConfiguration(configuration).
            findAll { isOsgiProject(it.dependencyProject) }

        log.debug "osgi projects: ${allOsgiProjects}"

        Collection<File> allProjectJars = jarsForProjectDependencies(allOsgiProjects)

        // if the project passed also generates a bundle, add its jar(s) to the result
        if (isOsgiProject(project)) {
            allProjectJars.addAll(jarsForArtifacts(configuration))
        }

        log.debug "OSGi project bundles: ${allProjectJars.sort()}"

        return allProjectJars
    }

    /**
     * Does the project use the "osgi" plugin?
     */
    static boolean isOsgiProject(Project project) {
        if (project == null) throw new IllegalArgumentException("project == null")
        return project.plugins.findPlugin('osgi') != null
    }

    /**
     * Returns all jar files generated by the project dependencies in the configuration that use the "osgi" plugin.
     */
    @Nonnull
    static Collection<File> projectJars(@Nonnull Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")

        def projectDependencies = projectDependenciesForConfiguration(configuration)
        def allProjectJars = jarsForProjectDependencies(projectDependencies)

        log.debug "Project JARs: ${allProjectJars.sort()}"

        return allProjectJars
    }


    @Nonnull
    private static Collection<File> jarsForProjectDependencies(Collection<ProjectDependency> projectDependencies) {
        return projectDependencies.collectMany { ProjectDependency dep ->
            jarsForArtifacts(dep.projectConfiguration)
        }
    }


    @Nonnull
    static Collection<File> jarsForArtifacts(@Nonnull Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")
        def allArtifacts = configuration.allArtifacts
        def fileCollection = allArtifacts.files
        def setOfFiles = fileCollection.files
        setOfFiles.findAll { JAR_NAME_PATTERN.matcher(it.name).matches() }
    }


    @Nonnull
    private static Collection<ProjectDependency> projectDependenciesForConfiguration(Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")

        DependencySet dependencies = configuration.allDependencies

        def projDeps = dependencies.findAll { it instanceof ProjectDependency } as Collection<ProjectDependency>

        log.debug "Project Dependencies: ${projDeps.collect { it.dependencyProject.path }.sort()}"

        return flattenProjectDependencies(projDeps)
    }

    /**
     * Recurse through the project dependencies and return a set of every one encountered.
     */
    @Nonnull
    private static Set<ProjectDependency> flattenProjectDependencies(Collection<ProjectDependency> projDeps) {
        if (projDeps == null || projDeps.isEmpty()) return EMPTY_SET

        // not very efficient, but works.
        // assumes there's no cycles, which would be caught earlier by Gradle
        Set<ProjectDependency> allProjDeps = new HashSet<>(projDeps)
        for (ProjectDependency dep : projDeps) {
            allProjDeps.addAll(projectDependenciesForProjDep(dep))
        }
        return allProjDeps
    }


    @Nonnull
    private static Collection<ProjectDependency> projectDependenciesForProjDep(ProjectDependency projectDependency) {
        if (projectDependency == null) return EMPTY_LIST

        DependencySet dependencies = projectDependency.projectConfiguration.allDependencies

        def projDeps = dependencies.findAll { it instanceof ProjectDependency } as Collection<ProjectDependency>

        log.debug "Project Dependencies for ${projectDependency.dependencyProject.name}:" +
            " ${projDeps.collect { it.dependencyProject.path }.sort()}"

        return flattenProjectDependencies(projDeps)
    }

    /**
     * Returns all the Projects for the project dependencies in the Configuration.
     */
    @Nonnull
    static Collection<Project> projectDependencyProjects(@Nonnull Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")
        return projectDependenciesForConfiguration(configuration).collect { it.dependencyProject }
    }

    /**
     * Returns all files for dependencies not generated by projects in the configuration.
     */
    @Nonnull
    static Collection<File> nonProjectDependencyBundleFiles(@Nonnull Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")

        def allDepFiles = allDependencyFiles(configuration)

        def projFiles = projectJars(configuration) as Set<File>
        log.debug "All proj files: ${projFiles}"

        // Remove the project-generated files from the list of all possible files, then copy it into a List
        def nonProjDepFiles = (allDepFiles - projFiles) as List<File>

        // TODO Filter out any files that may not actually be OSGi bundles

        log.debug "Non-project Bundles: ${nonProjDepFiles.sort()}"

        return nonProjDepFiles
    }


    private static Set<File> allDependencyFiles(Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")

        DependencySet dependencies = configuration.allDependencies

        def context = new CachingDependencyResolveContext(true)

        def resolvableDependencies = dependencies.findAll {
            it instanceof ResolvableDependency
        } as Collection<ResolvableDependency>
        resolvableDependencies.each { it.resolve(context) }

        def allDepFiles = configuration.resolve()
        log.debug "All dep files: ${allDepFiles}"

        return allDepFiles
    }

    /**
     * Returns all files for all bundle dependencies in the configuration.
     * Effectively the union of {@link #nonProjectDependencyBundleFiles(Configuration)}
     * and {@link #allProjectBundleJarFiles(Project, Configuration)}.
     */
    @Nonnull
    static Collection<File> allBundleFiles(@Nonnull Project project, @Nonnull Configuration configuration) {
        if (configuration == null) throw new IllegalArgumentException("configuration == null")
        if (project == null) throw new IllegalArgumentException("project == null")

        Collection<File> allProj = allProjectBundleJarFiles(project, configuration)
        Collection<File> allNonProj = nonProjectDependencyBundleFiles(configuration)

        return (allProj + allNonProj) as Set<File> // de-dupe the files
    }

}
